{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a / b + (a % b == 0 ? 0 : 1);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeCast.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128) {\n        require(value >= type(int128).min && value <= type(int128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return int128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64) {\n        require(value >= type(int64).min && value <= type(int64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return int64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32) {\n        require(value >= type(int32).min && value <= type(int32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return int32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16) {\n        require(value >= type(int16).min && value <= type(int16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return int16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8) {\n        require(value >= type(int8).min && value <= type(int8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return int8(value);\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "contracts/InterestRateModelV2.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.13;\n\nimport \"./InterestRateModelXAI.sol\";\nimport \"./lib/EasyMathV2.sol\";\n\ninterface IGenericInterestRateModel {\n    function config(address _silo, address _asset) external view returns (IInterestRateModel.Config memory);\n}\n\n/// @title InterestRateModelV2\n/// @notice Dynamic interest rate model implementation\n/// @dev Model stores some Silo specific data. If model is replaced, it needs to set proper config after redeployment\n/// for seamless service. Please refer to separate litepaper about model for design details.\n/// @custom:security-contact security@silo.finance\ncontract InterestRateModelV2 is InterestRateModelXAI {\n    using SafeCast for int256;\n    using SafeCast for uint256;\n\n    constructor(Config memory _config, address _owner) InterestRateModelXAI(_config) {\n        if (_owner != address(0) && _owner != msg.sender) {\n            transferOwnership(_owner);\n        }\n    }\n\n    /// @dev migration method for models before InterestRateModelV2\n    /// @param _silos array of Silos addresses for which config will be cloned\n    /// @param _siloRepository SiloRepository addresses\n    function migrationFromV1(address[] calldata _silos, ISiloRepository _siloRepository)\n        external\n        virtual\n        onlyOwner\n    {\n        IInterestRateModel model;\n\n        for (uint256 i; i < _silos.length;) {\n            address[] memory assets = ISilo(_silos[i]).getAssets();\n\n            if (address(model) == address(0)) {\n                // assumption is that XAI is not first asset otherwise this optimisation will not work\n                model = _siloRepository.getInterestRateModel(_silos[0], assets[0]);\n            }\n\n            for (uint256 j; j < assets.length;) {\n                Config memory clonedConfig = IGenericInterestRateModel(address(model)).config(_silos[i], assets[j]);\n\n                if (clonedConfig.uopt == 0) {\n                    IInterestRateModel secondModel = _siloRepository.getInterestRateModel(_silos[i], assets[j]);\n                    clonedConfig = IGenericInterestRateModel(address(secondModel)).config(_silos[i], assets[j]);\n                }\n\n                // in order not to clone empty config, check `uopt` - based on requirements it can not be 0\n                if (clonedConfig.uopt != 0) {\n                    // beta is divided by value of 4 for all configs, except stableLowCap, stableHighCap and bridgeXAI\n                    // With current values of beta parameter, volatile assets will get their interest rate\n                    // (proportional term) multiplied by 2 in one hour. Division of beta coefficient by 4 will result\n                    // in changing time for to double from one hour to four hours, which will make the interest rate\n                    // model behaviour less risky,\n                    // If we will forget about integral term (which will have less impact in first hours of critical\n                    // utilisation), proportional term will grow linear. It will double in first 4 hours,\n                    // triple in 8, x4 in 12, etc.\n                    if (clonedConfig.beta == 277777777777778) {\n                        clonedConfig.beta = 69444444444444;\n                    }\n\n                    // when we `setConfig()` we call `accrueInterest()`\n                    // we don't have to do it when we cloning, because config will not change\n                    _setConfig(_silos[i], assets[j], clonedConfig);\n                }\n\n                unchecked { j++; }\n            }\n\n            unchecked { i++; }\n        }\n    }\n\n    /// @inheritdoc IInterestRateModel\n    function calculateCurrentInterestRate( // solhint-disable-line function-max-lines\n        Config memory _c,\n        uint256 _totalDeposits,\n        uint256 _totalBorrowAmount,\n        uint256 _interestRateTimestamp,\n        uint256 _blockTimestamp\n    ) public pure virtual override returns (uint256 rcur) {\n        if (_interestRateTimestamp > _blockTimestamp) revert InvalidTimestamps();\n\n        // struct for local vars to avoid \"Stack too deep\"\n        LocalVarsRCur memory _l = LocalVarsRCur(0,0,0,0,0,0,false);\n\n        (,,,_l.overflow) = calculateCompoundInterestRateWithOverflowDetection(\n            _c,\n            _totalDeposits,\n            _totalBorrowAmount,\n            _interestRateTimestamp,\n            _blockTimestamp\n        );\n\n        if (_l.overflow) {\n            return 0;\n        }\n\n        // There can't be an underflow in the subtraction because of the previous check\n        unchecked {\n            // T := t1 - t0 # length of time period in seconds\n            _l.T = (_blockTimestamp - _interestRateTimestamp).toInt256();\n        }\n\n        _l.u = EasyMathV2.calculateUtilization(DP, _totalDeposits, _totalBorrowAmount).toInt256();\n        _l.DP = int256(DP);\n\n        if (_l.u > _c.ucrit) {\n            // rp := kcrit *(1 + Tcrit + beta *T)*( u0 - ucrit )\n            _l.rp = _c.kcrit * (_l.DP + _c.Tcrit + _c.beta * _l.T) / _l.DP * (_l.u - _c.ucrit) / _l.DP;\n        } else {\n            // rp := min (0, klow * (u0 - ulow ))\n            _l.rp = _min(0, _c.klow * (_l.u - _c.ulow) / _l.DP);\n        }\n\n        // rlin := klin * u0 # lower bound between t0 and t1\n        _l.rlin = _c.klin * _l.u / _l.DP;\n        // ri := max(ri , rlin )\n        _l.ri = _max(_c.ri, _l.rlin);\n        // ri := max(ri + ki * (u0 - uopt ) * T, rlin )\n        _l.ri = _max(_l.ri + _c.ki * (_l.u - _c.uopt) * _l.T / _l.DP, _l.rlin);\n        // rcur := max (ri + rp , rlin ) # current per second interest rate\n        rcur = (_max(_l.ri + _l.rp, _l.rlin)).toUint256();\n        rcur *= 365 days;\n\n        return _currentInterestRateCAP(rcur);\n    }\n\n    /// @inheritdoc IInterestRateModel\n    function calculateCompoundInterestRateWithOverflowDetection( // solhint-disable-line function-max-lines\n        Config memory _c,\n        uint256 _totalDeposits,\n        uint256 _totalBorrowAmount,\n        uint256 _interestRateTimestamp,\n        uint256 _blockTimestamp\n    ) public pure virtual override returns (\n        uint256 rcomp,\n        int256 ri,\n        int256 Tcrit, // solhint-disable-line var-name-mixedcase\n        bool overflow\n    ) {\n        ri = _c.ri;\n        Tcrit = _c.Tcrit;\n\n        // struct for local vars to avoid \"Stack too deep\"\n        LocalVarsRComp memory _l = LocalVarsRComp(0,0,0,0,0,0,0,0,0,0);\n\n        if (_interestRateTimestamp > _blockTimestamp) revert InvalidTimestamps();\n\n        // There can't be an underflow in the subtraction because of the previous check\n        unchecked {\n            // length of time period in seconds\n            _l.T = (_blockTimestamp - _interestRateTimestamp).toInt256();\n        }\n\n        int256 _DP = int256(DP); // solhint-disable-line var-name-mixedcase\n\n        _l.u = EasyMathV2.calculateUtilization(DP, _totalDeposits, _totalBorrowAmount).toInt256();\n\n        // slopei := ki * (u0 - uopt )\n        _l.slopei = _c.ki * (_l.u - _c.uopt) / _DP;\n\n        if (_l.u > _c.ucrit) {\n            // rp := kcrit * (1 + Tcrit) * (u0 - ucrit )\n            _l.rp = _c.kcrit * (_DP + Tcrit) / _DP * (_l.u - _c.ucrit) / _DP;\n            // slope := slopei + kcrit * beta * (u0 - ucrit )\n            _l.slope = _l.slopei + _c.kcrit * _c.beta / _DP * (_l.u - _c.ucrit) / _DP;\n            // Tcrit := Tcrit + beta * T\n            Tcrit = Tcrit + _c.beta * _l.T;\n        } else {\n            // rp := min (0, klow * (u0 - ulow ))\n            _l.rp = _min(0, _c.klow * (_l.u - _c.ulow) / _DP);\n            // slope := slopei\n            _l.slope = _l.slopei;\n            // Tcrit := max (0, Tcrit - beta * T)\n            Tcrit = _max(0, Tcrit - _c.beta * _l.T);\n        }\n\n        // rlin := klin * u0 # lower bound between t0 and t1\n        _l.rlin = _c.klin * _l.u / _DP;\n        // ri := max(ri , rlin )\n        ri = _max(ri , _l.rlin);\n        // r0 := ri + rp # interest rate at t0 ignoring lower bound\n        _l.r0 = ri + _l.rp;\n        // r1 := r0 + slope *T # what interest rate would be at t1 ignoring lower bound\n        _l.r1 = _l.r0 + _l.slope * _l.T;\n\n        // Calculating the compound interest\n\n        if (_l.r0 >= _l.rlin && _l.r1 >= _l.rlin) {\n            // lower bound isn’t activated\n            // rcomp := exp (( r0 + r1) * T / 2) - 1\n            _l.x = (_l.r0 + _l.r1) * _l.T / 2;\n        } else if (_l.r0 < _l.rlin && _l.r1 < _l.rlin) {\n            // lower bound is active during the whole time\n            // rcomp := exp( rlin * T) - 1\n            _l.x = _l.rlin * _l.T;\n        } else if (_l.r0 >= _l.rlin && _l.r1 < _l.rlin) {\n            // lower bound is active after some time\n            // rcomp := exp( rlin *T - (r0 - rlin )^2/ slope /2) - 1\n            _l.x = _l.rlin * _l.T - (_l.r0 - _l.rlin)**2 / _l.slope / 2;\n        } else {\n            // lower bound is active before some time\n            // rcomp := exp( rlin *T + (r1 - rlin )^2/ slope /2) - 1\n            _l.x = _l.rlin * _l.T + (_l.r1 - _l.rlin)**2 / _l.slope / 2;\n        }\n\n        // ri := max(ri + slopei * T, rlin )\n        ri = _max(ri + _l.slopei * _l.T, _l.rlin);\n\n        // Checking for the overflow below. In case of the overflow, ri and Tcrit will be set back to zeros. Rcomp is\n        // calculated to not make an overflow in totalBorrowedAmount, totalDeposits.\n        (rcomp, overflow) = _calculateRComp(_totalDeposits, _totalBorrowAmount, _l.x);\n\n        // if we got a limit for rcomp, we reset Tcrit and Ri model parameters to zeros\n        // Resetting parameters will make IR drop from 10k%/year to 100% per year and it will start growing again.\n        // If we don’t reset, we will have to wait ~2 weeks to make IR drop (low utilisation ratio required).\n        // So zeroing parameters is a only hope for a market to get well again, otherwise it will be almost impossible.\n        bool capApplied;\n\n        (rcomp, capApplied) = _compoundInterestRateCAP(rcomp, _l.T.toUint256());\n\n        if (overflow || capApplied) {\n            ri = 0;\n            Tcrit = 0;\n        }\n    }\n\n    /// @dev in order to keep methods pure and bee able to deploy easily new caps,\n    /// that method with hardcoded CAP was created\n    /// @notice limit for compounding interest rcomp := RCOMP_CAP * _l.T.\n    /// The limit is simple. Let’s threat our interest rate model as the black box. And for past _l.T time we got\n    /// a value for rcomp. We need to provide the top limit this value to take into account the limit for current\n    /// interest. Let’s imagine, if we had maximum allowed interest for _l.T. `RCOMP_CAP * _l.T` will be the value of\n    /// rcomp in this case, which will serve as the limit.\n    /// If we got this limit, we should make Tcrit and Ri equal to zero, otherwise there is a low probability of the\n    /// market going back below the limit.\n    function _compoundInterestRateCAP(uint256 _rcomp, uint256 _t)\n        internal\n        pure\n        virtual\n        returns (uint256 updatedRcomp, bool capApplied) {\n        // uint256 cap = 10**20 / (365 * 24 * 3600); // this is per-second rate because _l.T is in seconds.\n        uint256 cap = 3170979198376 * _t;\n        return _rcomp > cap ? (cap, true) : (_rcomp, false);\n    }\n\n    /// @notice limit for rcur - RCUR_CAP (FE/integrations, does not affect our protocol).\n    /// This is the limit for current interest rate, we picked 10k% of interest per year. Interest rate model is working\n    /// as expected before that threshold and simply sets the maximum value in case of limit.\n    /// 10k% is a really significant threshold, which will mean the death of market in most of cases.\n    /// Before 10k% interest rate can be good for certain market conditions.\n    /// We don’t read the current interest rate in our protocol, because we care only about the interest we compounded\n    /// over the past time since the last update. It is used in UI and other protocols integrations,\n    /// for example investing strategies.\n    function _currentInterestRateCAP(uint256 _rcur) internal pure virtual returns (uint256) {\n        uint256 cap = 1e20; // 10**20; this is 10,000% APR in the 18-decimals format.\n        return _rcur > cap ? cap : _rcur;\n    }\n}\n"
    },
    "contracts/InterestRateModelXAI.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport \"./lib/PRBMathSD59x18.sol\";\nimport \"./lib/EasyMathV2.sol\";\nimport \"./interfaces/ISilo.sol\";\nimport \"./interfaces/IInterestRateModel.sol\";\nimport \"./utils/TwoStepOwnable.sol\";\n\n/// @title InterestRateModelXAI\n/// @notice Dynamic interest rate model implementation\n/// @dev Model stores some Silo specific data. If model is replaced, it needs to set proper config after redeployment\n/// for seamless service. Please refer to separate litepaper about model for design details.\n/// Difference between original `InterestRateModel` is that we made methods to be `virtual` and :\n///     if (_config.ki < 0) revert InvalidKi();  --- was ... <= 0\n//      if (_config.kcrit < 0) revert InvalidKcrit();  --- was ... <= 0\n/// @custom:security-contact security@silo.finance\nabstract contract InterestRateModelXAI is IInterestRateModel, TwoStepOwnable {\n    using PRBMathSD59x18 for int256;\n    using SafeCast for int256;\n    using SafeCast for uint256;\n\n    /// @dev DP is 18 decimal points used for integer calculations\n    uint256 public constant override DP = 1e18;\n\n    /// @dev maximum value of compound interest the model will return\n    uint256 public constant RCOMP_MAX = (2**16) * 1e18;\n\n    /// @dev maximum value of X for which, RCOMP_MAX should be returned. If x > X_MAX => exp(x) > RCOMP_MAX.\n    /// X_MAX = ln(RCOMP_MAX + 1)\n    int256 public constant X_MAX = 11090370147631773313;\n\n    /// @dev maximum allowed amount for accruedInterest, totalDeposits and totalBorrowedAmount\n    /// after adding compounded interest. If rcomp cause this values to overflow, rcomp is reduced.\n    /// 196 bits max allowed for an asset amounts because the multiplication product with\n    /// decimal points (10^18) should not cause an overflow. 196 < log2(2^256 / 10^18)\n    uint256 public constant ASSET_DATA_OVERFLOW_LIMIT = 2**196;\n\n    // Silo => asset => ModelData\n    mapping(address => mapping(address => Config)) public config;\n\n    /// @notice Emitted on config change\n    /// @param silo Silo address for which config should be set\n    /// @param asset asset address for which config should be set\n    /// @param config config struct for asset in Silo\n    event ConfigUpdate(address indexed silo, address indexed asset, Config config);\n\n    error InvalidBeta();\n    error InvalidKcrit();\n    error InvalidKi();\n    error InvalidKlin();\n    error InvalidKlow();\n    error InvalidTcrit();\n    error InvalidTimestamps();\n    error InvalidUcrit();\n    error InvalidUlow();\n    error InvalidUopt();\n    error InvalidRi();\n\n    constructor(Config memory _config) {\n        _setConfig(address(0), address(0), _config);\n    }\n\n    /// @inheritdoc IInterestRateModel\n    function setConfig(address _silo, address _asset, Config calldata _config) external virtual override onlyOwner {\n        // we do not care, if accrueInterest call will be successful\n        // solhint-disable-next-line avoid-low-level-calls\n        _silo.call(abi.encodeCall(ISilo.accrueInterest, _asset));\n\n        _setConfig(_silo, _asset, _config);\n    }\n\n    /// @inheritdoc IInterestRateModel\n    function getCompoundInterestRateAndUpdate(\n        address _asset,\n        uint256 _blockTimestamp\n    ) external virtual override returns (uint256 rcomp) {\n        // assume that caller is Silo\n        address silo = msg.sender;\n\n        ISilo.UtilizationData memory data = ISilo(silo).utilizationData(_asset);\n\n        // TODO when depositing, we doing two calls for `calculateCompoundInterestRate`, maybe we can optimize?\n        Config storage currentConfig = config[silo][_asset];\n\n        (rcomp, currentConfig.ri, currentConfig.Tcrit) = calculateCompoundInterestRate(\n            getConfig(silo, _asset),\n            data.totalDeposits,\n            data.totalBorrowAmount,\n            data.interestRateTimestamp,\n            _blockTimestamp\n        );\n    }\n\n    /// @inheritdoc IInterestRateModel\n    function getCompoundInterestRate(\n        address _silo,\n        address _asset,\n        uint256 _blockTimestamp\n    ) external view virtual override returns (uint256 rcomp) {\n        ISilo.UtilizationData memory data = ISilo(_silo).utilizationData(_asset);\n\n        (rcomp,,) = calculateCompoundInterestRate(\n            getConfig(_silo, _asset),\n            data.totalDeposits,\n            data.totalBorrowAmount,\n            data.interestRateTimestamp,\n            _blockTimestamp\n        );\n    }\n\n    /// @inheritdoc IInterestRateModel\n    function overflowDetected(\n        address _silo,\n        address _asset,\n        uint256 _blockTimestamp\n    ) external view virtual override returns (bool overflow) {\n        ISilo.UtilizationData memory data = ISilo(_silo).utilizationData(_asset);\n\n        (,,,overflow) = calculateCompoundInterestRateWithOverflowDetection(\n            getConfig(_silo, _asset),\n            data.totalDeposits,\n            data.totalBorrowAmount,\n            data.interestRateTimestamp,\n            _blockTimestamp\n        );\n    }\n\n    /// @inheritdoc IInterestRateModel\n    function getCurrentInterestRate(\n        address _silo,\n        address _asset,\n        uint256 _blockTimestamp\n    ) external view virtual override returns (uint256 rcur) {\n        ISilo.UtilizationData memory data = ISilo(_silo).utilizationData(_asset);\n\n        rcur = calculateCurrentInterestRate(\n            getConfig(_silo, _asset),\n            data.totalDeposits,\n            data.totalBorrowAmount,\n            data.interestRateTimestamp,\n            _blockTimestamp\n        );\n    }\n\n    /// @inheritdoc IInterestRateModel\n    function getConfig(address _silo, address _asset) public view virtual override returns (Config memory) {\n        Config storage currentConfig = config[_silo][_asset];\n\n        if (currentConfig.uopt != 0) {\n            return currentConfig;\n        }\n\n        // use default config\n        Config memory c = config[address(0)][address(0)];\n\n        // model data is always stored for each silo and asset so default values must be replaced\n        c.ri = currentConfig.ri;\n        c.Tcrit = currentConfig.Tcrit;\n        return c;\n    }\n\n    /* solhint-disable */\n\n    struct LocalVarsRCur {\n        int256 T;\n        int256 u;\n        int256 DP;\n        int256 rp;\n        int256 rlin;\n        int256 ri;\n        bool overflow;\n    }\n\n    /// @inheritdoc IInterestRateModel\n    function calculateCurrentInterestRate(\n        Config memory _c,\n        uint256 _totalDeposits,\n        uint256 _totalBorrowAmount,\n        uint256 _interestRateTimestamp,\n        uint256 _blockTimestamp\n    ) public pure virtual override returns (uint256 rcur) {\n        if (_interestRateTimestamp > _blockTimestamp) revert InvalidTimestamps();\n\n        // struct for local vars to avoid \"Stack too deep\"\n        LocalVarsRCur memory _l = LocalVarsRCur(0,0,0,0,0,0,false);\n\n        (,,,_l.overflow) = calculateCompoundInterestRateWithOverflowDetection(\n            _c,\n            _totalDeposits,\n            _totalBorrowAmount,\n            _interestRateTimestamp,\n            _blockTimestamp\n        );\n\n        if (_l.overflow) {\n            return 0;\n        }\n\n        // There can't be an underflow in the subtraction because of the previous check\n        unchecked {\n            // T := t1 - t0 # length of time period in seconds\n            _l.T = (_blockTimestamp - _interestRateTimestamp).toInt256();\n        }\n\n        _l.u = EasyMathV2.calculateUtilization(DP, _totalDeposits, _totalBorrowAmount).toInt256();\n        _l.DP = int256(DP);\n\n        if (_l.u > _c.ucrit) {\n            // rp := kcrit *(1 + Tcrit + beta *T)*( u0 - ucrit )\n            _l.rp = _c.kcrit * (_l.DP + _c.Tcrit + _c.beta * _l.T) / _l.DP * (_l.u - _c.ucrit) / _l.DP;\n        } else {\n            // rp := min (0, klow * (u0 - ulow ))\n            _l.rp = _min(0, _c.klow * (_l.u - _c.ulow) / _l.DP);\n        }\n\n        // rlin := klin * u0 # lower bound between t0 and t1\n        _l.rlin = _c.klin * _l.u / _l.DP;\n        // ri := max(ri , rlin )\n        _l.ri = _max(_c.ri, _l.rlin);\n        // ri := max(ri + ki * (u0 - uopt ) * T, rlin )\n        _l.ri = _max(_l.ri + _c.ki * (_l.u - _c.uopt) * _l.T / _l.DP, _l.rlin);\n        // rcur := max (ri + rp , rlin ) # current per second interest rate\n        rcur = (_max(_l.ri + _l.rp, _l.rlin)).toUint256();\n        rcur *= 365 days;\n    }\n\n    struct LocalVarsRComp {\n        int256 T;\n        int256 slopei;\n        int256 rp;\n        int256 slope;\n        int256 r0;\n        int256 rlin;\n        int256 r1;\n        int256 x;\n        int256 rlin1;\n        int256 u;\n    }\n\n    function interestRateModelPing() external pure virtual override returns (bytes4) {\n        return this.interestRateModelPing.selector;\n    }\n\n    /// @inheritdoc IInterestRateModel\n    function calculateCompoundInterestRate(\n        Config memory _c,\n        uint256 _totalDeposits,\n        uint256 _totalBorrowAmount,\n        uint256 _interestRateTimestamp,\n        uint256 _blockTimestamp\n    ) public pure virtual override returns (\n        uint256 rcomp,\n        int256 ri,\n        int256 Tcrit\n    ) {\n        (rcomp, ri, Tcrit,) = calculateCompoundInterestRateWithOverflowDetection(\n            _c,\n            _totalDeposits,\n            _totalBorrowAmount,\n            _interestRateTimestamp,\n            _blockTimestamp\n        );\n    }\n\n    /// @inheritdoc IInterestRateModel\n    function calculateCompoundInterestRateWithOverflowDetection(\n        Config memory _c,\n        uint256 _totalDeposits,\n        uint256 _totalBorrowAmount,\n        uint256 _interestRateTimestamp,\n        uint256 _blockTimestamp\n    ) public pure virtual override returns (\n        uint256 rcomp,\n        int256 ri,\n        int256 Tcrit,\n        bool overflow\n    ) {\n        ri = _c.ri;\n        Tcrit = _c.Tcrit;\n\n        // struct for local vars to avoid \"Stack too deep\"\n        LocalVarsRComp memory _l = LocalVarsRComp(0,0,0,0,0,0,0,0,0,0);\n\n        if (_interestRateTimestamp > _blockTimestamp) revert InvalidTimestamps();\n\n        // There can't be an underflow in the subtraction because of the previous check\n    unchecked {\n        // length of time period in seconds\n        _l.T = (_blockTimestamp - _interestRateTimestamp).toInt256();\n    }\n\n        int256 _DP = int256(DP);\n\n        _l.u = EasyMathV2.calculateUtilization(DP, _totalDeposits, _totalBorrowAmount).toInt256();\n\n        // slopei := ki * (u0 - uopt )\n        _l.slopei = _c.ki * (_l.u - _c.uopt) / _DP;\n\n        if (_l.u > _c.ucrit) {\n            // rp := kcrit * (1 + Tcrit) * (u0 - ucrit )\n            _l.rp = _c.kcrit * (_DP + Tcrit) / _DP * (_l.u - _c.ucrit) / _DP;\n            // slope := slopei + kcrit * beta * (u0 - ucrit )\n            _l.slope = _l.slopei + _c.kcrit * _c.beta / _DP * (_l.u - _c.ucrit) / _DP;\n            // Tcrit := Tcrit + beta * T\n            Tcrit = Tcrit + _c.beta * _l.T;\n        } else {\n            // rp := min (0, klow * (u0 - ulow ))\n            _l.rp = _min(0, _c.klow * (_l.u - _c.ulow) / _DP);\n            // slope := slopei\n            _l.slope = _l.slopei;\n            // Tcrit := max (0, Tcrit - beta * T)\n            Tcrit = _max(0, Tcrit - _c.beta * _l.T);\n        }\n\n        // rlin := klin * u0 # lower bound between t0 and t1\n        _l.rlin = _c.klin * _l.u / _DP;\n        // ri := max(ri , rlin )\n        ri = _max(ri , _l.rlin);\n        // r0 := ri + rp # interest rate at t0 ignoring lower bound\n        _l.r0 = ri + _l.rp;\n        // r1 := r0 + slope *T # what interest rate would be at t1 ignoring lower bound\n        _l.r1 = _l.r0 + _l.slope * _l.T;\n\n        // Calculating the compound interest\n\n        if (_l.r0 >= _l.rlin && _l.r1 >= _l.rlin) {\n            // lower bound isn’t activated\n            // rcomp := exp (( r0 + r1) * T / 2) - 1\n            _l.x = (_l.r0 + _l.r1) * _l.T / 2;\n        } else if (_l.r0 < _l.rlin && _l.r1 < _l.rlin) {\n            // lower bound is active during the whole time\n            // rcomp := exp( rlin * T) - 1\n            _l.x = _l.rlin * _l.T;\n        } else if (_l.r0 >= _l.rlin && _l.r1 < _l.rlin) {\n            // lower bound is active after some time\n            // rcomp := exp( rlin *T - (r0 - rlin )^2/ slope /2) - 1\n            _l.x = _l.rlin * _l.T - (_l.r0 - _l.rlin)**2 / _l.slope / 2;\n        } else {\n            // lower bound is active before some time\n            // rcomp := exp( rlin *T + (r1 - rlin )^2/ slope /2) - 1\n            _l.x = _l.rlin * _l.T + (_l.r1 - _l.rlin)**2 / _l.slope / 2;\n        }\n\n        // ri := max(ri + slopei * T, rlin )\n        ri = _max(ri + _l.slopei * _l.T, _l.rlin);\n\n        // Checking for the overflow below. In case of the overflow, ri and Tcrit will be set back to zeros. Rcomp is\n        // calculated to not make an overflow in totalBorrowedAmount, totalDeposits.\n        (rcomp, overflow) = _calculateRComp(_totalDeposits, _totalBorrowAmount, _l.x);\n\n        if (overflow) {\n            ri = 0;\n            Tcrit = 0;\n        }\n    }\n\n    /// @dev set config for silo and asset\n    function _setConfig(address _silo, address _asset, Config memory _config) internal virtual {\n        int256 _DP = int256(DP);\n\n        if (_config.uopt <= 0 || _config.uopt >= _DP) revert InvalidUopt();\n        if (_config.ucrit <= _config.uopt || _config.ucrit >= _DP) revert InvalidUcrit();\n        if (_config.ulow <= 0 || _config.ulow >= _config.uopt) revert InvalidUlow();\n        if (_config.ki < 0) revert InvalidKi();\n        if (_config.kcrit < 0) revert InvalidKcrit();\n        if (_config.klow < 0) revert InvalidKlow();\n        if (_config.klin < 0) revert InvalidKlin();\n        if (_config.beta < 0) revert InvalidBeta();\n        if (_config.ri < 0) revert InvalidRi();\n        if (_config.Tcrit < 0) revert InvalidTcrit();\n\n        config[_silo][_asset] = _config;\n        emit ConfigUpdate(_silo, _asset, _config);\n    }\n\n    /* solhint-enable */\n\n    /// @dev checks for the overflow in rcomp calculations, accruedInterest, totalDeposits and totalBorrowedAmount.\n    /// In case of the overflow, rcomp is reduced to make totalDeposits and totalBorrowedAmount <= 2**196.\n    function _calculateRComp(\n        uint256 _totalDeposits,\n        uint256 _totalBorrowAmount,\n        int256 _x\n    ) internal pure virtual returns (uint256 rcomp, bool overflow) {\n        int256 rcompSigned;\n\n        if (_x >= X_MAX) {\n            rcomp = RCOMP_MAX;\n            // overflow, but not return now. It counts as an overflow to reset model parameters,\n            // but later on we can get overflow worse.\n            overflow = true;\n        } else {\n            rcompSigned = _x.exp() - int256(DP);\n            rcomp = rcompSigned > 0 ? rcompSigned.toUint256() : 0;\n        }\n\n        unchecked {\n            // maxAmount = max(_totalDeposits, _totalBorrowAmount) to see\n            // if any of this variables overflow in result.\n            uint256 maxAmount = _totalDeposits > _totalBorrowAmount ? _totalDeposits : _totalBorrowAmount;\n\n            if (maxAmount >= ASSET_DATA_OVERFLOW_LIMIT) {\n                return (0, true);\n            }\n\n            uint256 rcompMulTBA = rcomp * _totalBorrowAmount;\n\n            if (rcompMulTBA == 0) {\n                return (rcomp, overflow);\n            }\n\n            if (\n                rcompMulTBA / rcomp != _totalBorrowAmount ||\n                rcompMulTBA / DP > ASSET_DATA_OVERFLOW_LIMIT - maxAmount\n            ) {\n                rcomp = (ASSET_DATA_OVERFLOW_LIMIT - maxAmount) * DP / _totalBorrowAmount;\n\n                return (rcomp, true);\n            }\n        }\n    }\n\n    /// @dev Returns the largest of two numbers\n    function _max(int256 a, int256 b) internal pure virtual returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /// @dev Returns the smallest of two numbers\n    function _min(int256 a, int256 b) internal pure virtual returns (int256) {\n        return a < b ? a : b;\n    }\n}\n"
    },
    "contracts/interfaces/IBaseSilo.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.13;\n\nimport \"./IShareToken.sol\";\nimport \"./IFlashLiquidationReceiver.sol\";\nimport \"./ISiloRepository.sol\";\n\ninterface IBaseSilo {\n    enum AssetStatus { Undefined, Active, Removed }\n\n    /// @dev Storage struct that holds all required data for a single token market\n    struct AssetStorage {\n        /// @dev Token that represents a share in totalDeposits of Silo\n        IShareToken collateralToken;\n        /// @dev Token that represents a share in collateralOnlyDeposits of Silo\n        IShareToken collateralOnlyToken;\n        /// @dev Token that represents a share in totalBorrowAmount of Silo\n        IShareToken debtToken;\n        /// @dev COLLATERAL: Amount of asset token that has been deposited to Silo with interest earned by depositors.\n        /// It also includes token amount that has been borrowed.\n        uint256 totalDeposits;\n        /// @dev COLLATERAL ONLY: Amount of asset token that has been deposited to Silo that can be ONLY used\n        /// as collateral. These deposits do NOT earn interest and CANNOT be borrowed.\n        uint256 collateralOnlyDeposits;\n        /// @dev DEBT: Amount of asset token that has been borrowed with accrued interest.\n        uint256 totalBorrowAmount;\n    }\n\n    /// @dev Storage struct that holds data related to fees and interest\n    struct AssetInterestData {\n        /// @dev Total amount of already harvested protocol fees\n        uint256 harvestedProtocolFees;\n        /// @dev Total amount (ever growing) of asset token that has been earned by the protocol from\n        /// generated interest.\n        uint256 protocolFees;\n        /// @dev Timestamp of the last time `interestRate` has been updated in storage.\n        uint64 interestRateTimestamp;\n        /// @dev True if asset was removed from the protocol. If so, deposit and borrow functions are disabled\n        /// for that asset\n        AssetStatus status;\n    }\n\n    /// @notice data that InterestModel needs for calculations\n    struct UtilizationData {\n        uint256 totalDeposits;\n        uint256 totalBorrowAmount;\n        /// @dev timestamp of last interest accrual\n        uint64 interestRateTimestamp;\n    }\n\n    /// @dev Shares names and symbols that are generated while asset initialization\n    struct AssetSharesMetadata {\n        /// @dev Name for the collateral shares token\n        string collateralName;\n        /// @dev Symbol for the collateral shares token\n        string collateralSymbol;\n        /// @dev Name for the collateral only (protected collateral) shares token\n        string protectedName;\n        /// @dev Symbol for the collateral only (protected collateral) shares token\n        string protectedSymbol;\n        /// @dev Name for the debt shares token\n        string debtName;\n        /// @dev Symbol for the debt shares token\n        string debtSymbol;\n    }\n\n    /// @notice Emitted when deposit is made\n    /// @param asset asset address that was deposited\n    /// @param depositor wallet address that deposited asset\n    /// @param amount amount of asset that was deposited\n    /// @param collateralOnly type of deposit, true if collateralOnly deposit was used\n    event Deposit(address indexed asset, address indexed depositor, uint256 amount, bool collateralOnly);\n\n    /// @notice Emitted when withdraw is made\n    /// @param asset asset address that was withdrawn\n    /// @param depositor wallet address that deposited asset\n    /// @param receiver wallet address that received asset\n    /// @param amount amount of asset that was withdrew\n    /// @param collateralOnly type of withdraw, true if collateralOnly deposit was used\n    event Withdraw(\n        address indexed asset,\n        address indexed depositor,\n        address indexed receiver,\n        uint256 amount,\n        bool collateralOnly\n    );\n\n    /// @notice Emitted on asset borrow\n    /// @param asset asset address that was borrowed\n    /// @param user wallet address that borrowed asset\n    /// @param amount amount of asset that was borrowed\n    event Borrow(address indexed asset, address indexed user, uint256 amount);\n\n    /// @notice Emitted on asset repay\n    /// @param asset asset address that was repaid\n    /// @param user wallet address that repaid asset\n    /// @param amount amount of asset that was repaid\n    event Repay(address indexed asset, address indexed user, uint256 amount);\n\n    /// @notice Emitted on user liquidation\n    /// @param asset asset address that was liquidated\n    /// @param user wallet address that was liquidated\n    /// @param shareAmountRepaid amount of collateral-share token that was repaid. This is collateral token representing\n    /// ownership of underlying deposit.\n    /// @param seizedCollateral amount of underlying token that was seized by liquidator\n    event Liquidate(address indexed asset, address indexed user, uint256 shareAmountRepaid, uint256 seizedCollateral);\n\n    /// @notice Emitted when the status for an asset is updated\n    /// @param asset asset address that was updated\n    /// @param status new asset status\n    event AssetStatusUpdate(address indexed asset, AssetStatus indexed status);\n\n    /// @return version of the silo contract\n    function VERSION() external returns (uint128); // solhint-disable-line func-name-mixedcase\n\n    /// @notice Synchronize current bridge assets with Silo\n    /// @dev This function needs to be called on Silo deployment to setup all assets for Silo. It needs to be\n    /// called every time a bridged asset is added or removed. When bridge asset is removed, depositing and borrowing\n    /// should be disabled during asset sync.\n    function syncBridgeAssets() external;\n\n    /// @notice Get Silo Repository contract address\n    /// @return Silo Repository contract address\n    function siloRepository() external view returns (ISiloRepository);\n\n    /// @notice Get asset storage data\n    /// @param _asset asset address\n    /// @return AssetStorage struct\n    function assetStorage(address _asset) external view returns (AssetStorage memory);\n\n    /// @notice Get asset interest data\n    /// @param _asset asset address\n    /// @return AssetInterestData struct\n    function interestData(address _asset) external view returns (AssetInterestData memory);\n\n    /// @dev helper method for InterestRateModel calculations\n    function utilizationData(address _asset) external view returns (UtilizationData memory data);\n\n    /// @notice Calculates solvency of an account\n    /// @param _user wallet address for which solvency is calculated\n    /// @return true if solvent, false otherwise\n    function isSolvent(address _user) external view returns (bool);\n\n    /// @notice Returns all initialized (synced) assets of Silo including current and removed bridge assets\n    /// @return assets array of initialized assets of Silo\n    function getAssets() external view returns (address[] memory assets);\n\n    /// @notice Returns all initialized (synced) assets of Silo including current and removed bridge assets\n    /// with corresponding state\n    /// @return assets array of initialized assets of Silo\n    /// @return assetsStorage array of assets state corresponding to `assets` array\n    function getAssetsWithState() external view returns (address[] memory assets, AssetStorage[] memory assetsStorage);\n\n    /// @notice Check if depositing an asset for given account is possible\n    /// @dev Depositing an asset that has been already borrowed (and vice versa) is disallowed\n    /// @param _asset asset we want to deposit\n    /// @param _depositor depositor address\n    /// @return true if asset can be deposited by depositor\n    function depositPossible(address _asset, address _depositor) external view returns (bool);\n\n    /// @notice Check if borrowing an asset for given account is possible\n    /// @dev Borrowing an asset that has been already deposited (and vice versa) is disallowed\n    /// @param _asset asset we want to deposit\n    /// @param _borrower borrower address\n    /// @return true if asset can be borrowed by borrower\n    function borrowPossible(address _asset, address _borrower) external view returns (bool);\n\n    /// @dev Amount of token that is available for borrowing\n    /// @param _asset asset to get liquidity for\n    /// @return Silo liquidity\n    function liquidity(address _asset) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IFlashLiquidationReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\n/// @dev when performing Silo flash liquidation, FlashReceiver contract will receive all collaterals\ninterface IFlashLiquidationReceiver {\n    /// @dev this method is called when doing Silo flash liquidation\n    ///         one can NOT assume, that if _seizedCollateral[i] != 0, then _shareAmountsToRepaid[i] must be 0\n    ///         one should assume, that any combination of amounts is possible\n    ///         on callback, one must call `Silo.repayFor` because at the end of transaction,\n    ///         Silo will check if borrower is solvent.\n    /// @param _user user address, that is liquidated\n    /// @param _assets array of collateral assets received during user liquidation\n    ///         this array contains all assets (collateral borrowed) without any order\n    /// @param _receivedCollaterals array of collateral amounts received during user liquidation\n    ///         indexes of amounts are related to `_assets`,\n    /// @param _shareAmountsToRepaid array of amounts to repay for each asset\n    ///         indexes of amounts are related to `_assets`,\n    /// @param _flashReceiverData data that are passed from sender that executes liquidation\n    function siloLiquidationCallback(\n        address _user,\n        address[] calldata _assets,\n        uint256[] calldata _receivedCollaterals,\n        uint256[] calldata _shareAmountsToRepaid,\n        bytes memory _flashReceiverData\n    ) external;\n}\n"
    },
    "contracts/interfaces/IInterestRateModel.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.13;\n\ninterface IInterestRateModel {\n    /* solhint-disable */\n    struct Config {\n        // uopt ∈ (0, 1) – optimal utilization;\n        int256 uopt;\n        // ucrit ∈ (uopt, 1) – threshold of large utilization;\n        int256 ucrit;\n        // ulow ∈ (0, uopt) – threshold of low utilization\n        int256 ulow;\n        // ki > 0 – integrator gain\n        int256 ki;\n        // kcrit > 0 – proportional gain for large utilization\n        int256 kcrit;\n        // klow ≥ 0 – proportional gain for low utilization\n        int256 klow;\n        // klin ≥ 0 – coefficient of the lower linear bound\n        int256 klin;\n        // beta ≥ 0 - a scaling factor\n        int256 beta;\n        // ri ≥ 0 – initial value of the integrator\n        int256 ri;\n        // Tcrit ≥ 0 - the time during which the utilization exceeds the critical value\n        int256 Tcrit;\n    }\n    /* solhint-enable */\n\n    /// @dev Set dedicated config for given asset in a Silo. Config is per asset per Silo so different assets\n    /// in different Silo can have different configs.\n    /// It will try to call `_silo.accrueInterest(_asset)` before updating config, but it is not guaranteed,\n    /// that this call will be successful, if it fail config will be set anyway.\n    /// @param _silo Silo address for which config should be set\n    /// @param _asset asset address for which config should be set\n    function setConfig(address _silo, address _asset, Config calldata _config) external;\n\n    /// @dev get compound interest rate and update model storage\n    /// @param _asset address of an asset in Silo for which interest rate should be calculated\n    /// @param _blockTimestamp current block timestamp\n    /// @return rcomp compounded interest rate from last update until now (1e18 == 100%)\n    function getCompoundInterestRateAndUpdate(\n        address _asset,\n        uint256 _blockTimestamp\n    ) external returns (uint256 rcomp);\n\n    /// @dev Get config for given asset in a Silo. If dedicated config is not set, default one will be returned.\n    /// @param _silo Silo address for which config should be set\n    /// @param _asset asset address for which config should be set\n    /// @return Config struct for asset in Silo\n    function getConfig(address _silo, address _asset) external view returns (Config memory);\n\n    /// @dev get compound interest rate\n    /// @param _silo address of Silo\n    /// @param _asset address of an asset in Silo for which interest rate should be calculated\n    /// @param _blockTimestamp current block timestamp\n    /// @return rcomp compounded interest rate from last update until now (1e18 == 100%)\n    function getCompoundInterestRate(\n        address _silo,\n        address _asset,\n        uint256 _blockTimestamp\n    ) external view returns (uint256 rcomp);\n\n    /// @dev get current annual interest rate\n    /// @param _silo address of Silo\n    /// @param _asset address of an asset in Silo for which interest rate should be calculated\n    /// @param _blockTimestamp current block timestamp\n    /// @return rcur current annual interest rate (1e18 == 100%)\n    function getCurrentInterestRate(\n        address _silo,\n        address _asset,\n        uint256 _blockTimestamp\n    ) external view returns (uint256 rcur);\n\n    /// @notice get the flag to detect rcomp restriction (zero current interest) due to overflow\n    /// overflow boolean flag to detect rcomp restriction\n    function overflowDetected(\n        address _silo,\n        address _asset,\n        uint256 _blockTimestamp\n    ) external view returns (bool overflow);\n\n    /// @dev pure function that calculates current annual interest rate\n    /// @param _c configuration object, InterestRateModel.Config\n    /// @param _totalBorrowAmount current total borrows for asset\n    /// @param _totalDeposits current total deposits for asset\n    /// @param _interestRateTimestamp timestamp of last interest rate update\n    /// @param _blockTimestamp current block timestamp\n    /// @return rcur current annual interest rate (1e18 == 100%)\n    function calculateCurrentInterestRate(\n        Config memory _c,\n        uint256 _totalDeposits,\n        uint256 _totalBorrowAmount,\n        uint256 _interestRateTimestamp,\n        uint256 _blockTimestamp\n    ) external pure returns (uint256 rcur);\n\n    /// @dev pure function that calculates interest rate based on raw input data\n    /// @param _c configuration object, InterestRateModel.Config\n    /// @param _totalBorrowAmount current total borrows for asset\n    /// @param _totalDeposits current total deposits for asset\n    /// @param _interestRateTimestamp timestamp of last interest rate update\n    /// @param _blockTimestamp current block timestamp\n    /// @return rcomp compounded interest rate from last update until now (1e18 == 100%)\n    /// @return ri current integral part of the rate\n    /// @return Tcrit time during which the utilization exceeds the critical value\n    /// @return overflow boolean flag to detect rcomp restriction\n    function calculateCompoundInterestRateWithOverflowDetection(\n        Config memory _c,\n        uint256 _totalDeposits,\n        uint256 _totalBorrowAmount,\n        uint256 _interestRateTimestamp,\n        uint256 _blockTimestamp\n    ) external pure returns (\n        uint256 rcomp,\n        int256 ri,\n        int256 Tcrit, // solhint-disable-line var-name-mixedcase\n        bool overflow\n    );\n\n    /// @dev pure function that calculates interest rate based on raw input data\n    /// @param _c configuration object, InterestRateModel.Config\n    /// @param _totalBorrowAmount current total borrows for asset\n    /// @param _totalDeposits current total deposits for asset\n    /// @param _interestRateTimestamp timestamp of last interest rate update\n    /// @param _blockTimestamp current block timestamp\n    /// @return rcomp compounded interest rate from last update until now (1e18 == 100%)\n    /// @return ri current integral part of the rate\n    /// @return Tcrit time during which the utilization exceeds the critical value\n    function calculateCompoundInterestRate(\n        Config memory _c,\n        uint256 _totalDeposits,\n        uint256 _totalBorrowAmount,\n        uint256 _interestRateTimestamp,\n        uint256 _blockTimestamp\n    ) external pure returns (\n        uint256 rcomp,\n        int256 ri,\n        int256 Tcrit // solhint-disable-line var-name-mixedcase\n    );\n\n    /// @dev returns decimal points used by model\n    function DP() external pure returns (uint256); // solhint-disable-line func-name-mixedcase\n\n    /// @dev just a helper method to see if address is a InterestRateModel\n    /// @return always true\n    function interestRateModelPing() external pure returns (bytes4);\n}\n"
    },
    "contracts/interfaces/INotificationReceiver.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.13;\n\n/// @title Common interface for Silo Incentive Contract\ninterface INotificationReceiver {\n    /// @dev Informs the contract about token transfer\n    /// @param _token address of the token that was transferred\n    /// @param _from sender\n    /// @param _to receiver\n    /// @param _amount amount that was transferred\n    function onAfterTransfer(address _token, address _from, address _to, uint256 _amount) external;\n\n    /// @dev Sanity check function\n    /// @return always true\n    function notificationReceiverPing() external pure returns (bytes4);\n}\n"
    },
    "contracts/interfaces/IPriceProvider.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.7.6 <0.9.0;\n\n/// @title Common interface for Silo Price Providers\ninterface IPriceProvider {\n    /// @notice Returns \"Time-Weighted Average Price\" for an asset. Calculates TWAP price for quote/asset.\n    /// It unifies all tokens decimal to 18, examples:\n    /// - if asses == quote it returns 1e18\n    /// - if asset is USDC and quote is ETH and ETH costs ~$3300 then it returns ~0.0003e18 WETH per 1 USDC\n    /// @param _asset address of an asset for which to read price\n    /// @return price of asses with 18 decimals, throws when pool is not ready yet to provide price\n    function getPrice(address _asset) external view returns (uint256 price);\n\n    /// @dev Informs if PriceProvider is setup for asset. It does not means PriceProvider can provide price right away.\n    /// Some providers implementations need time to \"build\" buffer for TWAP price,\n    /// so price may not be available yet but this method will return true.\n    /// @param _asset asset in question\n    /// @return TRUE if asset has been setup, otherwise false\n    function assetSupported(address _asset) external view returns (bool);\n\n    /// @notice Gets token address in which prices are quoted\n    /// @return quoteToken address\n    function quoteToken() external view returns (address);\n\n    /// @notice Helper method that allows easily detects, if contract is PriceProvider\n    /// @dev this can save us from simple human errors, in case we use invalid address\n    /// but this should NOT be treated as security check\n    /// @return always true\n    function priceProviderPing() external pure returns (bytes4);\n}\n"
    },
    "contracts/interfaces/IPriceProvidersRepository.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.7.6 <0.9.0;\n\nimport \"./IPriceProvider.sol\";\n\ninterface IPriceProvidersRepository {\n    /// @notice Emitted when price provider is added\n    /// @param newPriceProvider new price provider address\n    event NewPriceProvider(IPriceProvider indexed newPriceProvider);\n\n    /// @notice Emitted when price provider is removed\n    /// @param priceProvider removed price provider address\n    event PriceProviderRemoved(IPriceProvider indexed priceProvider);\n\n    /// @notice Emitted when asset is assigned to price provider\n    /// @param asset assigned asset   address\n    /// @param priceProvider price provider address\n    event PriceProviderForAsset(address indexed asset, IPriceProvider indexed priceProvider);\n\n    /// @notice Register new price provider\n    /// @param _priceProvider address of price provider\n    function addPriceProvider(IPriceProvider _priceProvider) external;\n\n    /// @notice Unregister price provider\n    /// @param _priceProvider address of price provider to be removed\n    function removePriceProvider(IPriceProvider _priceProvider) external;\n\n    /// @notice Sets price provider for asset\n    /// @dev Request for asset price is forwarded to the price provider assigned to that asset\n    /// @param _asset address of an asset for which price provider will be used\n    /// @param _priceProvider address of price provider\n    function setPriceProviderForAsset(address _asset, IPriceProvider _priceProvider) external;\n\n    /// @notice Returns \"Time-Weighted Average Price\" for an asset\n    /// @param _asset address of an asset for which to read price\n    /// @return price TWAP price of a token with 18 decimals\n    function getPrice(address _asset) external view returns (uint256 price);\n\n    /// @notice Gets price provider assigned to an asset\n    /// @param _asset address of an asset for which to get price provider\n    /// @return priceProvider address of price provider\n    function priceProviders(address _asset) external view returns (IPriceProvider priceProvider);\n\n    /// @notice Gets token address in which prices are quoted\n    /// @return quoteToken address\n    function quoteToken() external view returns (address);\n\n    /// @notice Gets manager role address\n    /// @return manager role address\n    function manager() external view returns (address);\n\n    /// @notice Checks if providers are available for an asset\n    /// @param _asset asset address to check\n    /// @return returns TRUE if price feed is ready, otherwise false\n    function providersReadyForAsset(address _asset) external view returns (bool);\n\n    /// @notice Returns true if address is a registered price provider\n    /// @param _provider address of price provider to be removed\n    /// @return true if address is a registered price provider, otherwise false\n    function isPriceProvider(IPriceProvider _provider) external view returns (bool);\n\n    /// @notice Gets number of price providers registered\n    /// @return number of price providers registered\n    function providersCount() external view returns (uint256);\n\n    /// @notice Gets an array of price providers\n    /// @return array of price providers\n    function providerList() external view returns (address[] memory);\n\n    /// @notice Sanity check function\n    /// @return returns always TRUE\n    function priceProvidersRepositoryPing() external pure returns (bytes4);\n}\n"
    },
    "contracts/interfaces/IShareToken.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport \"./INotificationReceiver.sol\";\n\ninterface IShareToken is IERC20Metadata {\n    /// @notice Emitted every time receiver is notified about token transfer\n    /// @param notificationReceiver receiver address\n    /// @param success false if TX reverted on `notificationReceiver` side, otherwise true\n    event NotificationSent(\n        INotificationReceiver indexed notificationReceiver,\n        bool success\n    );\n\n    /// @notice Mint method for Silo to create debt position\n    /// @param _account wallet for which to mint token\n    /// @param _amount amount of token to be minted\n    function mint(address _account, uint256 _amount) external;\n\n    /// @notice Burn method for Silo to close debt position\n    /// @param _account wallet for which to burn token\n    /// @param _amount amount of token to be burned\n    function burn(address _account, uint256 _amount) external;\n}\n"
    },
    "contracts/interfaces/ISilo.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.13;\n\nimport \"./IBaseSilo.sol\";\n\ninterface ISilo is IBaseSilo {\n    /// @notice Deposit `_amount` of `_asset` tokens from `msg.sender` to the Silo\n    /// @param _asset The address of the token to deposit\n    /// @param _amount The amount of the token to deposit\n    /// @param _collateralOnly True if depositing collateral only\n    /// @return collateralAmount deposited amount\n    /// @return collateralShare user collateral shares based on deposited amount\n    function deposit(address _asset, uint256 _amount, bool _collateralOnly)\n        external\n        returns (uint256 collateralAmount, uint256 collateralShare);\n\n    /// @notice Router function to deposit `_amount` of `_asset` tokens to the Silo for the `_depositor`\n    /// @param _asset The address of the token to deposit\n    /// @param _depositor The address of the recipient of collateral tokens\n    /// @param _amount The amount of the token to deposit\n    /// @param _collateralOnly True if depositing collateral only\n    /// @return collateralAmount deposited amount\n    /// @return collateralShare `_depositor` collateral shares based on deposited amount\n    function depositFor(address _asset, address _depositor, uint256 _amount, bool _collateralOnly)\n        external\n        returns (uint256 collateralAmount, uint256 collateralShare);\n\n    /// @notice Withdraw `_amount` of `_asset` tokens from the Silo to `msg.sender`\n    /// @param _asset The address of the token to withdraw\n    /// @param _amount The amount of the token to withdraw\n    /// @param _collateralOnly True if withdrawing collateral only deposit\n    /// @return withdrawnAmount withdrawn amount that was transferred to user\n    /// @return withdrawnShare burned share based on `withdrawnAmount`\n    function withdraw(address _asset, uint256 _amount, bool _collateralOnly)\n        external\n        returns (uint256 withdrawnAmount, uint256 withdrawnShare);\n\n    /// @notice Router function to withdraw `_amount` of `_asset` tokens from the Silo for the `_depositor`\n    /// @param _asset The address of the token to withdraw\n    /// @param _depositor The address that originally deposited the collateral tokens being withdrawn,\n    /// it should be the one initiating the withdrawal through the router\n    /// @param _receiver The address that will receive the withdrawn tokens\n    /// @param _amount The amount of the token to withdraw\n    /// @param _collateralOnly True if withdrawing collateral only deposit\n    /// @return withdrawnAmount withdrawn amount that was transferred to `_receiver`\n    /// @return withdrawnShare burned share based on `withdrawnAmount`\n    function withdrawFor(\n        address _asset,\n        address _depositor,\n        address _receiver,\n        uint256 _amount,\n        bool _collateralOnly\n    ) external returns (uint256 withdrawnAmount, uint256 withdrawnShare);\n\n    /// @notice Borrow `_amount` of `_asset` tokens from the Silo to `msg.sender`\n    /// @param _asset The address of the token to borrow\n    /// @param _amount The amount of the token to borrow\n    /// @return debtAmount borrowed amount\n    /// @return debtShare user debt share based on borrowed amount\n    function borrow(address _asset, uint256 _amount) external returns (uint256 debtAmount, uint256 debtShare);\n\n    /// @notice Router function to borrow `_amount` of `_asset` tokens from the Silo for the `_receiver`\n    /// @param _asset The address of the token to borrow\n    /// @param _borrower The address that will take the loan,\n    /// it should be the one initiating the borrowing through the router\n    /// @param _receiver The address of the asset receiver\n    /// @param _amount The amount of the token to borrow\n    /// @return debtAmount borrowed amount\n    /// @return debtShare `_receiver` debt share based on borrowed amount\n    function borrowFor(address _asset, address _borrower, address _receiver, uint256 _amount)\n        external\n        returns (uint256 debtAmount, uint256 debtShare);\n\n    /// @notice Repay `_amount` of `_asset` tokens from `msg.sender` to the Silo\n    /// @param _asset The address of the token to repay\n    /// @param _amount amount of asset to repay, includes interests\n    /// @return repaidAmount amount repaid\n    /// @return burnedShare burned debt share\n    function repay(address _asset, uint256 _amount) external returns (uint256 repaidAmount, uint256 burnedShare);\n\n    /// @notice Allows to repay in behalf of borrower to execute liquidation\n    /// @param _asset The address of the token to repay\n    /// @param _borrower The address of the user to have debt tokens burned\n    /// @param _amount amount of asset to repay, includes interests\n    /// @return repaidAmount amount repaid\n    /// @return burnedShare burned debt share\n    function repayFor(address _asset, address _borrower, uint256 _amount)\n        external\n        returns (uint256 repaidAmount, uint256 burnedShare);\n\n    /// @dev harvest protocol fees from an array of assets\n    /// @return harvestedAmounts amount harvested during tx execution for each of silo asset\n    function harvestProtocolFees() external returns (uint256[] memory harvestedAmounts);\n\n    /// @notice Function to update interests for `_asset` token since the last saved state\n    /// @param _asset The address of the token to be updated\n    /// @return interest accrued interest\n    function accrueInterest(address _asset) external returns (uint256 interest);\n\n    /// @notice this methods does not requires to have tokens in order to liquidate user\n    /// @dev during liquidation process, msg.sender will be notified once all collateral will be send to him\n    /// msg.sender needs to be `IFlashLiquidationReceiver`\n    /// @param _users array of users to liquidate\n    /// @param _flashReceiverData this data will be forward to msg.sender on notification\n    /// @return assets array of all processed assets (collateral + debt, including removed)\n    /// @return receivedCollaterals receivedCollaterals[userId][assetId] => amount\n    /// amounts of collaterals send to `_flashReceiver`\n    /// @return shareAmountsToRepaid shareAmountsToRepaid[userId][assetId] => amount\n    /// required amounts of debt to be repaid\n    function flashLiquidate(address[] memory _users, bytes memory _flashReceiverData)\n        external\n        returns (\n            address[] memory assets,\n            uint256[][] memory receivedCollaterals,\n            uint256[][] memory shareAmountsToRepaid\n        );\n}\n"
    },
    "contracts/interfaces/ISiloFactory.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.13;\n\ninterface ISiloFactory {\n    /// @notice Emitted when Silo is deployed\n    /// @param silo address of deployed Silo\n    /// @param asset address of asset for which Silo was deployed\n    /// @param version version of silo implementation\n    event NewSiloCreated(address indexed silo, address indexed asset, uint128 version);\n\n    /// @notice Must be called by repository on constructor\n    /// @param _siloRepository the SiloRepository to set\n    function initRepository(address _siloRepository) external;\n\n    /// @notice Deploys Silo\n    /// @param _siloAsset unique asset for which Silo is deployed\n    /// @param _version version of silo implementation\n    /// @param _data (optional) data that may be needed during silo creation\n    /// @return silo deployed Silo address\n    function createSilo(address _siloAsset, uint128 _version, bytes memory _data) external returns (address silo);\n\n    /// @dev just a helper method to see if address is a factory\n    function siloFactoryPing() external pure returns (bytes4);\n}\n"
    },
    "contracts/interfaces/ISiloRepository.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.13;\n\nimport \"./ISiloFactory.sol\";\nimport \"./ITokensFactory.sol\";\nimport \"./IPriceProvidersRepository.sol\";\nimport \"./INotificationReceiver.sol\";\nimport \"./IInterestRateModel.sol\";\n\ninterface ISiloRepository {\n    /// @dev protocol fees in precision points (Solvency._PRECISION_DECIMALS), we do allow for fee == 0\n    struct Fees {\n        /// @dev One time protocol fee for opening a borrow position in precision points (Solvency._PRECISION_DECIMALS)\n        uint64 entryFee;\n        /// @dev Protocol revenue share in interest paid in precision points (Solvency._PRECISION_DECIMALS)\n        uint64 protocolShareFee;\n        /// @dev Protocol share in liquidation profit in precision points (Solvency._PRECISION_DECIMALS).\n        /// It's calculated from total collateral amount to be transferred to liquidator.\n        uint64 protocolLiquidationFee;\n    }\n\n    struct SiloVersion {\n        /// @dev Default version of Silo. If set to 0, it means it is not set. By default it is set to 1\n        uint128 byDefault;\n\n        /// @dev Latest added version of Silo. If set to 0, it means it is not set. By default it is set to 1\n        uint128 latest;\n    }\n\n    /// @dev AssetConfig struct represents configurable parameters for each Silo\n    struct AssetConfig {\n        /// @dev Loan-to-Value ratio represents the maximum borrowing power of a specific collateral.\n        ///      For example, if the collateral asset has an LTV of 75%, the user can borrow up to 0.75 worth\n        ///      of quote token in the principal currency for every quote token worth of collateral.\n        ///      value uses 18 decimals eg. 100% == 1e18\n        ///      max valid value is 1e18 so it needs storage of 60 bits\n        uint64 maxLoanToValue;\n\n        /// @dev Liquidation Threshold represents the threshold at which a borrow position will be considered\n        ///      undercollateralized and subject to liquidation for each collateral. For example,\n        ///      if a collateral has a liquidation threshold of 80%, it means that the loan will be\n        ///      liquidated when the borrowAmount value is worth 80% of the collateral value.\n        ///      value uses 18 decimals eg. 100% == 1e18\n        uint64 liquidationThreshold;\n\n        /// @dev interest rate model address\n        IInterestRateModel interestRateModel;\n    }\n\n    event NewDefaultMaximumLTV(uint64 defaultMaximumLTV);\n\n    event NewDefaultLiquidationThreshold(uint64 defaultLiquidationThreshold);\n\n    /// @notice Emitted on new Silo creation\n    /// @param silo deployed Silo address\n    /// @param asset unique asset for deployed Silo\n    /// @param siloVersion version of deployed Silo\n    event NewSilo(address indexed silo, address indexed asset, uint128 siloVersion);\n\n    /// @notice Emitted when new Silo (or existing one) becomes a bridge pool (pool with only bridge tokens).\n    /// @param pool address of the bridge pool, It can be zero address when bridge asset is removed and pool no longer\n    /// is treated as bridge pool\n    event BridgePool(address indexed pool);\n\n    /// @notice Emitted on new bridge asset\n    /// @param newBridgeAsset address of added bridge asset\n    event BridgeAssetAdded(address indexed newBridgeAsset);\n\n    /// @notice Emitted on removed bridge asset\n    /// @param bridgeAssetRemoved address of removed bridge asset\n    event BridgeAssetRemoved(address indexed bridgeAssetRemoved);\n\n    /// @notice Emitted when default interest rate model is changed\n    /// @param newModel address of new interest rate model\n    event InterestRateModel(IInterestRateModel indexed newModel);\n\n    /// @notice Emitted on price provider repository address update\n    /// @param newProvider address of new oracle repository\n    event PriceProvidersRepositoryUpdate(\n        IPriceProvidersRepository indexed newProvider\n    );\n\n    /// @notice Emitted on token factory address update\n    /// @param newTokensFactory address of new token factory\n    event TokensFactoryUpdate(address indexed newTokensFactory);\n\n    /// @notice Emitted on router address update\n    /// @param newRouter address of new router\n    event RouterUpdate(address indexed newRouter);\n\n    /// @notice Emitted on INotificationReceiver address update\n    /// @param newIncentiveContract address of new INotificationReceiver\n    event NotificationReceiverUpdate(INotificationReceiver indexed newIncentiveContract);\n\n    /// @notice Emitted when new Silo version is registered\n    /// @param factory factory address that deploys registered Silo version\n    /// @param siloLatestVersion Silo version of registered Silo\n    /// @param siloDefaultVersion current default Silo version\n    event RegisterSiloVersion(address indexed factory, uint128 siloLatestVersion, uint128 siloDefaultVersion);\n\n    /// @notice Emitted when Silo version is unregistered\n    /// @param factory factory address that deploys unregistered Silo version\n    /// @param siloVersion version that was unregistered\n    event UnregisterSiloVersion(address indexed factory, uint128 siloVersion);\n\n    /// @notice Emitted when default Silo version is updated\n    /// @param newDefaultVersion new default version\n    event SiloDefaultVersion(uint128 newDefaultVersion);\n\n    /// @notice Emitted when default fee is updated\n    /// @param newEntryFee new entry fee\n    /// @param newProtocolShareFee new protocol share fee\n    /// @param newProtocolLiquidationFee new protocol liquidation fee\n    event FeeUpdate(\n        uint64 newEntryFee,\n        uint64 newProtocolShareFee,\n        uint64 newProtocolLiquidationFee\n    );\n\n    /// @notice Emitted when asset config is updated for a silo\n    /// @param silo silo for which asset config is being set\n    /// @param asset asset for which asset config is being set\n    /// @param assetConfig new asset config\n    event AssetConfigUpdate(address indexed silo, address indexed asset, AssetConfig assetConfig);\n\n    /// @notice Emitted when silo (silo factory) version is set for asset\n    /// @param asset asset for which asset config is being set\n    /// @param version Silo version\n    event VersionForAsset(address indexed asset, uint128 version);\n\n    /// @param _siloAsset silo asset\n    /// @return version of Silo that is assigned for provided asset, if not assigned it returns zero (default)\n    function getVersionForAsset(address _siloAsset) external returns (uint128);\n\n    /// @notice setter for `getVersionForAsset` mapping\n    /// @param _siloAsset silo asset\n    /// @param _version version of Silo that will be assigned for `_siloAsset`, zero (default) is acceptable\n    function setVersionForAsset(address _siloAsset, uint128 _version) external;\n\n    /// @notice use this method only when off-chain verification is OFF\n    /// @dev Silo does NOT support rebase and deflationary tokens\n    /// @param _siloAsset silo asset\n    /// @param _siloData (optional) data that may be needed during silo creation\n    /// @return createdSilo address of created silo\n    function newSilo(address _siloAsset, bytes memory _siloData) external returns (address createdSilo);\n\n    /// @notice use this method to deploy new version of Silo for an asset that already has Silo deployed.\n    /// Only owner (DAO) can replace.\n    /// @dev Silo does NOT support rebase and deflationary tokens\n    /// @param _siloAsset silo asset\n    /// @param _siloVersion version of silo implementation. Use 0 for default version which is fine\n    /// for 99% of cases.\n    /// @param _siloData (optional) data that may be needed during silo creation\n    /// @return createdSilo address of created silo\n    function replaceSilo(\n        address _siloAsset,\n        uint128 _siloVersion,\n        bytes memory _siloData\n    ) external returns (address createdSilo);\n\n    /// @notice Set factory contract for debt and collateral tokens for each Silo asset\n    /// @dev Callable only by owner\n    /// @param _tokensFactory address of TokensFactory contract that deploys debt and collateral tokens\n    function setTokensFactory(address _tokensFactory) external;\n\n    /// @notice Set default fees\n    /// @dev Callable only by owner\n    /// @param _fees:\n    /// - _entryFee one time protocol fee for opening a borrow position in precision points\n    /// (Solvency._PRECISION_DECIMALS)\n    /// - _protocolShareFee protocol revenue share in interest paid in precision points\n    /// (Solvency._PRECISION_DECIMALS)\n    /// - _protocolLiquidationFee protocol share in liquidation profit in precision points\n    /// (Solvency._PRECISION_DECIMALS). It's calculated from total collateral amount to be transferred\n    /// to liquidator.\n    function setFees(Fees calldata _fees) external;\n\n    /// @notice Set configuration for given asset in given Silo\n    /// @dev Callable only by owner\n    /// @param _silo Silo address for which config applies\n    /// @param _asset asset address for which config applies\n    /// @param _assetConfig:\n    ///    - _maxLoanToValue maximum Loan-to-Value, for details see `Repository.AssetConfig.maxLoanToValue`\n    ///    - _liquidationThreshold liquidation threshold, for details see `Repository.AssetConfig.maxLoanToValue`\n    ///    - _interestRateModel interest rate model address, for details see `Repository.AssetConfig.interestRateModel`\n    function setAssetConfig(\n        address _silo,\n        address _asset,\n        AssetConfig calldata _assetConfig\n    ) external;\n\n    /// @notice Set default interest rate model\n    /// @dev Callable only by owner\n    /// @param _defaultInterestRateModel default interest rate model\n    function setDefaultInterestRateModel(IInterestRateModel _defaultInterestRateModel) external;\n\n    /// @notice Set default maximum LTV\n    /// @dev Callable only by owner\n    /// @param _defaultMaxLTV default maximum LTV in precision points (Solvency._PRECISION_DECIMALS)\n    function setDefaultMaximumLTV(uint64 _defaultMaxLTV) external;\n\n    /// @notice Set default liquidation threshold\n    /// @dev Callable only by owner\n    /// @param _defaultLiquidationThreshold default liquidation threshold in precision points\n    /// (Solvency._PRECISION_DECIMALS)\n    function setDefaultLiquidationThreshold(uint64 _defaultLiquidationThreshold) external;\n\n    /// @notice Set price provider repository\n    /// @dev Callable only by owner\n    /// @param _repository price provider repository address\n    function setPriceProvidersRepository(IPriceProvidersRepository _repository) external;\n\n    /// @notice Set router contract\n    /// @dev Callable only by owner\n    /// @param _router router address\n    function setRouter(address _router) external;\n\n    /// @notice Set NotificationReceiver contract\n    /// @dev Callable only by owner\n    /// @param _silo silo address for which to set `_notificationReceiver`\n    /// @param _notificationReceiver NotificationReceiver address\n    function setNotificationReceiver(address _silo, INotificationReceiver _notificationReceiver) external;\n\n    /// @notice Adds new bridge asset\n    /// @dev New bridge asset must be unique. Duplicates in bridge assets are not allowed. It's possible to add\n    /// bridge asset that has been removed in the past. Note that all Silos must be synced manually. Callable\n    /// only by owner.\n    /// @param _newBridgeAsset bridge asset address\n    function addBridgeAsset(address _newBridgeAsset) external;\n\n    /// @notice Removes bridge asset\n    /// @dev Note that all Silos must be synced manually. Callable only by owner.\n    /// @param _bridgeAssetToRemove bridge asset address to be removed\n    function removeBridgeAsset(address _bridgeAssetToRemove) external;\n\n    /// @notice Registers new Silo version\n    /// @dev User can choose which Silo version he wants to deploy. It's possible to have multiple versions of Silo.\n    /// Callable only by owner.\n    /// @param _factory factory contract that deploys new version of Silo\n    /// @param _isDefault true if this version should be used as default\n    function registerSiloVersion(ISiloFactory _factory, bool _isDefault) external;\n\n    /// @notice Unregisters Silo version\n    /// @dev Callable only by owner.\n    /// @param _siloVersion Silo version to be unregistered\n    function unregisterSiloVersion(uint128 _siloVersion) external;\n\n    /// @notice Sets default Silo version\n    /// @dev Callable only by owner.\n    /// @param _defaultVersion Silo version to be set as default\n    function setDefaultSiloVersion(uint128 _defaultVersion) external;\n\n    /// @notice Check if contract address is a Silo deployment\n    /// @param _silo address of expected Silo\n    /// @return true if address is Silo deployment, otherwise false\n    function isSilo(address _silo) external view returns (bool);\n\n    /// @notice Get Silo address of asset\n    /// @param _asset address of asset\n    /// @return address of corresponding Silo deployment\n    function getSilo(address _asset) external view returns (address);\n\n    /// @notice Get Silo Factory for given version\n    /// @param _siloVersion version of Silo implementation\n    /// @return ISiloFactory contract that deploys Silos of given version\n    function siloFactory(uint256 _siloVersion) external view returns (ISiloFactory);\n\n    /// @notice Get debt and collateral Token Factory\n    /// @return ITokensFactory contract that deploys debt and collateral tokens\n    function tokensFactory() external view returns (ITokensFactory);\n\n    /// @notice Get Router contract\n    /// @return address of router contract\n    function router() external view returns (address);\n\n    /// @notice Get current bridge assets\n    /// @dev Keep in mind that not all Silos may be synced with current bridge assets so it's possible that some\n    /// assets in that list are not part of given Silo.\n    /// @return address array of bridge assets\n    function getBridgeAssets() external view returns (address[] memory);\n\n    /// @notice Get removed bridge assets\n    /// @dev Keep in mind that not all Silos may be synced with bridge assets so it's possible that some\n    /// assets in that list are still part of given Silo.\n    /// @return address array of bridge assets\n    function getRemovedBridgeAssets() external view returns (address[] memory);\n\n    /// @notice Get maximum LTV for asset in given Silo\n    /// @dev If dedicated config is not set, method returns default config\n    /// @param _silo address of Silo\n    /// @param _asset address of an asset\n    /// @return maximum LTV in precision points (Solvency._PRECISION_DECIMALS)\n    function getMaximumLTV(address _silo, address _asset) external view returns (uint256);\n\n    /// @notice Get Interest Rate Model address for asset in given Silo\n    /// @dev If dedicated config is not set, method returns default config\n    /// @param _silo address of Silo\n    /// @param _asset address of an asset\n    /// @return address of interest rate model\n    function getInterestRateModel(address _silo, address _asset) external view returns (IInterestRateModel);\n\n    /// @notice Get liquidation threshold for asset in given Silo\n    /// @dev If dedicated config is not set, method returns default config\n    /// @param _silo address of Silo\n    /// @param _asset address of an asset\n    /// @return liquidation threshold in precision points (Solvency._PRECISION_DECIMALS)\n    function getLiquidationThreshold(address _silo, address _asset) external view returns (uint256);\n\n    /// @notice Get incentive contract address. Incentive contracts are responsible for distributing rewards\n    /// to debt and/or collateral token holders of given Silo\n    /// @param _silo address of Silo\n    /// @return incentive contract address\n    function getNotificationReceiver(address _silo) external view returns (INotificationReceiver);\n\n    /// @notice Get owner role address of Repository\n    /// @return owner role address\n    function owner() external view returns (address);\n\n    /// @notice get PriceProvidersRepository contract that manages price providers implementations\n    /// @return IPriceProvidersRepository address\n    function priceProvidersRepository() external view returns (IPriceProvidersRepository);\n\n    /// @dev Get protocol fee for opening a borrow position\n    /// @return fee in precision points (Solvency._PRECISION_DECIMALS == 100%)\n    function entryFee() external view returns (uint256);\n\n    /// @dev Get protocol share fee\n    /// @return protocol share fee in precision points (Solvency._PRECISION_DECIMALS == 100%)\n    function protocolShareFee() external view returns (uint256);\n\n    /// @dev Get protocol liquidation fee\n    /// @return protocol liquidation fee in precision points (Solvency._PRECISION_DECIMALS == 100%)\n    function protocolLiquidationFee() external view returns (uint256);\n\n    /// @dev Checks all conditions for new silo creation and throws when not possible to create\n    /// @param _asset address of asset for which you want to create silo\n    /// @param _assetIsABridge bool TRUE when `_asset` is bridge asset, FALSE when it is not\n    function ensureCanCreateSiloFor(address _asset, bool _assetIsABridge) external view;\n\n    function siloRepositoryPing() external pure returns (bytes4);\n}\n"
    },
    "contracts/interfaces/ITokensFactory.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.13;\n\nimport \"./IShareToken.sol\";\n\ninterface ITokensFactory {\n    /// @notice Emitted when collateral token is deployed\n    /// @param token address of deployed collateral token\n    event NewShareCollateralTokenCreated(address indexed token);\n\n    /// @notice Emitted when collateral token is deployed\n    /// @param token address of deployed debt token\n    event NewShareDebtTokenCreated(address indexed token);\n\n    ///@notice Must be called by repository on constructor\n    /// @param _siloRepository the SiloRepository to set\n    function initRepository(address _siloRepository) external;\n\n    /// @notice Deploys collateral token\n    /// @param _name name of the token\n    /// @param _symbol symbol of the token\n    /// @param _asset underlying asset for which token is deployed\n    /// @return address of deployed collateral share token\n    function createShareCollateralToken(\n        string memory _name,\n        string memory _symbol,\n        address _asset\n    ) external returns (IShareToken);\n\n    /// @notice Deploys debt token\n    /// @param _name name of the token\n    /// @param _symbol symbol of the token\n    /// @param _asset underlying asset for which token is deployed\n    /// @return address of deployed debt share token\n    function createShareDebtToken(\n        string memory _name,\n        string memory _symbol,\n        address _asset\n    )\n        external\n        returns (IShareToken);\n\n    /// @dev just a helper method to see if address is a factory\n    /// @return always true\n    function tokensFactoryPing() external pure returns (bytes4);\n}\n"
    },
    "contracts/lib/EasyMathV2.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.13;\n\n/// @dev EasyMathV2 is optimised version of EasyMath, many places was `unchecked` for lower gas cost.\n/// There is also fixed version of `calculateUtilization()` method.\nlibrary EasyMathV2 {\n    error ZeroAssets();\n    error ZeroShares();\n\n    function toShare(uint256 amount, uint256 totalAmount, uint256 totalShares)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        if (totalShares == 0 || totalAmount == 0) {\n            return amount;\n        }\n\n        result = amount * totalShares;\n        // totalAmount is never 0 based on above check, so we can uncheck\n        unchecked { result /= totalAmount; }\n\n        // Prevent rounding error\n        if (result == 0 && amount != 0) {\n            revert ZeroShares();\n        }\n    }\n\n    function toShareRoundUp(uint256 amount, uint256 totalAmount, uint256 totalShares)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        if (totalShares == 0 || totalAmount == 0) {\n            return amount;\n        }\n\n        uint256 numerator = amount * totalShares;\n        // totalAmount is not 0, so it is safe to uncheck\n        unchecked { result = numerator / totalAmount; }\n        \n        // Round up\n        if (numerator % totalAmount != 0) {\n            unchecked { result += 1; }\n        }\n    }\n\n    function toAmount(uint256 share, uint256 totalAmount, uint256 totalShares)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        if (totalShares == 0 || totalAmount == 0) {\n            return 0;\n        }\n\n        result = share * totalAmount;\n        // totalShares are not 0, so we can uncheck\n        unchecked { result /= totalShares; }\n\n        // Prevent rounding error\n        if (result == 0 && share != 0) {\n            revert ZeroAssets();\n        }\n    }\n\n    function toAmountRoundUp(uint256 share, uint256 totalAmount, uint256 totalShares)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        if (totalShares == 0 || totalAmount == 0) {\n            return 0;\n        }\n\n        uint256 numerator = share * totalAmount;\n        // totalShares are not 0, based on above check, so we can uncheck\n        unchecked { result = numerator / totalShares; }\n        \n        // Round up\n        if (numerator % totalShares != 0) {\n            unchecked { result += 1; }\n        }\n    }\n\n    function toValue(uint256 _assetAmount, uint256 _assetPrice, uint256 _assetDecimals)\n        internal\n        pure\n        returns (uint256 value)\n    {\n        value = _assetAmount * _assetPrice;\n        // power of 10 can not be 0, so we can uncheck\n        unchecked { value /= 10 ** _assetDecimals; }\n    }\n\n    function sum(uint256[] memory _numbers) internal pure returns (uint256 s) {\n        for(uint256 i; i < _numbers.length;) {\n            s += _numbers[i];\n            unchecked { i++; }\n        }\n    }\n\n    /// @notice Calculates fraction between borrowed and deposited amount of tokens denominated in percentage\n    /// @dev It assumes `_dp` = 100%.\n    /// @param _dp decimal points used by model\n    /// @param _totalDeposits current total deposits for assets\n    /// @param _totalBorrowAmount current total borrows for assets\n    /// @return utilization value, capped to 100%\n    /// Limiting utilisation ratio by 100% max will allows us to perform better interest rate computations\n    /// and should not affect any other part of protocol.\n    function calculateUtilization(uint256 _dp, uint256 _totalDeposits, uint256 _totalBorrowAmount)\n        internal\n        pure\n        returns (uint256 utilization)\n    {\n        if (_totalDeposits == 0 || _totalBorrowAmount == 0) return 0;\n\n        utilization = _totalBorrowAmount * _dp;\n        // _totalDeposits is not 0 based on above check, so it is safe to uncheck this division\n        unchecked { utilization /= _totalDeposits; }\n\n        // cap at 100%\n        if (utilization > _dp) utilization = _dp;\n    }\n}\n"
    },
    "contracts/lib/PRBMathCommon.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity 0.8.13;\n\n/* solhint-disable */\n/// @dev Common mathematical functions used in both PRBMathSD59x18 and PRBMathUD60x18. Note that this shared library\n/// does not always assume the signed 59.18-decimal fixed-point or the unsigned 60.18-decimal fixed-point\n// representation. When it does not, it is annonated in the function's NatSpec documentation.\n/// @author Paul Razvan Berg\nlibrary PRBMathCommon {\n    /// @dev How many trailing decimals can be represented.\n    uint256 internal constant SCALE = 1e18;\n\n    /// @notice Calculates the binary exponent of x using the binary fraction method.\n    /// @dev Uses 128.128-bit fixed-point numbers - it is the most efficient way.\n    /// @param x The exponent as an unsigned 128.128-bit fixed-point number.\n    /// @return result The result as an unsigned 60x18 decimal fixed-point number.\n    function exp2(uint256 x) internal pure returns (uint256 result) {\n        unchecked {\n            // Start from 0.5 in the 128.128-bit fixed-point format. We need to use uint256 because the intermediary\n            // may get very close to 2^256, which doesn't fit in int256.\n            result = 0x80000000000000000000000000000000;\n\n            // Multiply the result by root(2, 2^-i) when the bit at position i is 1. None of the intermediary results overflows\n            // because the initial result is 2^127 and all magic factors are less than 2^129.\n            if (x & 0x80000000000000000000000000000000 > 0) result = (result * 0x16A09E667F3BCC908B2FB1366EA957D3E) >> 128;\n            if (x & 0x40000000000000000000000000000000 > 0) result = (result * 0x1306FE0A31B7152DE8D5A46305C85EDED) >> 128;\n            if (x & 0x20000000000000000000000000000000 > 0) result = (result * 0x1172B83C7D517ADCDF7C8C50EB14A7920) >> 128;\n            if (x & 0x10000000000000000000000000000000 > 0) result = (result * 0x10B5586CF9890F6298B92B71842A98364) >> 128;\n            if (x & 0x8000000000000000000000000000000 > 0) result = (result * 0x1059B0D31585743AE7C548EB68CA417FE) >> 128;\n            if (x & 0x4000000000000000000000000000000 > 0) result = (result * 0x102C9A3E778060EE6F7CACA4F7A29BDE9) >> 128;\n            if (x & 0x2000000000000000000000000000000 > 0) result = (result * 0x10163DA9FB33356D84A66AE336DCDFA40) >> 128;\n            if (x & 0x1000000000000000000000000000000 > 0) result = (result * 0x100B1AFA5ABCBED6129AB13EC11DC9544) >> 128;\n            if (x & 0x800000000000000000000000000000 > 0) result = (result * 0x10058C86DA1C09EA1FF19D294CF2F679C) >> 128;\n            if (x & 0x400000000000000000000000000000 > 0) result = (result * 0x1002C605E2E8CEC506D21BFC89A23A011) >> 128;\n            if (x & 0x200000000000000000000000000000 > 0) result = (result * 0x100162F3904051FA128BCA9C55C31E5E0) >> 128;\n            if (x & 0x100000000000000000000000000000 > 0) result = (result * 0x1000B175EFFDC76BA38E31671CA939726) >> 128;\n            if (x & 0x80000000000000000000000000000 > 0) result = (result * 0x100058BA01FB9F96D6CACD4B180917C3E) >> 128;\n            if (x & 0x40000000000000000000000000000 > 0) result = (result * 0x10002C5CC37DA9491D0985C348C68E7B4) >> 128;\n            if (x & 0x20000000000000000000000000000 > 0) result = (result * 0x1000162E525EE054754457D5995292027) >> 128;\n            if (x & 0x10000000000000000000000000000 > 0) result = (result * 0x10000B17255775C040618BF4A4ADE83FD) >> 128;\n            if (x & 0x8000000000000000000000000000 > 0) result = (result * 0x1000058B91B5BC9AE2EED81E9B7D4CFAC) >> 128;\n            if (x & 0x4000000000000000000000000000 > 0) result = (result * 0x100002C5C89D5EC6CA4D7C8ACC017B7CA) >> 128;\n            if (x & 0x2000000000000000000000000000 > 0) result = (result * 0x10000162E43F4F831060E02D839A9D16D) >> 128;\n            if (x & 0x1000000000000000000000000000 > 0) result = (result * 0x100000B1721BCFC99D9F890EA06911763) >> 128;\n            if (x & 0x800000000000000000000000000 > 0) result = (result * 0x10000058B90CF1E6D97F9CA14DBCC1629) >> 128;\n            if (x & 0x400000000000000000000000000 > 0) result = (result * 0x1000002C5C863B73F016468F6BAC5CA2C) >> 128;\n            if (x & 0x200000000000000000000000000 > 0) result = (result * 0x100000162E430E5A18F6119E3C02282A6) >> 128;\n            if (x & 0x100000000000000000000000000 > 0) result = (result * 0x1000000B1721835514B86E6D96EFD1BFF) >> 128;\n            if (x & 0x80000000000000000000000000 > 0) result = (result * 0x100000058B90C0B48C6BE5DF846C5B2F0) >> 128;\n            if (x & 0x40000000000000000000000000 > 0) result = (result * 0x10000002C5C8601CC6B9E94213C72737B) >> 128;\n            if (x & 0x20000000000000000000000000 > 0) result = (result * 0x1000000162E42FFF037DF38AA2B219F07) >> 128;\n            if (x & 0x10000000000000000000000000 > 0) result = (result * 0x10000000B17217FBA9C739AA5819F44FA) >> 128;\n            if (x & 0x8000000000000000000000000 > 0) result = (result * 0x1000000058B90BFCDEE5ACD3C1CEDC824) >> 128;\n            if (x & 0x4000000000000000000000000 > 0) result = (result * 0x100000002C5C85FE31F35A6A30DA1BE51) >> 128;\n            if (x & 0x2000000000000000000000000 > 0) result = (result * 0x10000000162E42FF0999CE3541B9FFFD0) >> 128;\n            if (x & 0x1000000000000000000000000 > 0) result = (result * 0x100000000B17217F80F4EF5AADDA45554) >> 128;\n            if (x & 0x800000000000000000000000 > 0) result = (result * 0x10000000058B90BFBF8479BD5A81B51AE) >> 128;\n            if (x & 0x400000000000000000000000 > 0) result = (result * 0x1000000002C5C85FDF84BD62AE30A74CD) >> 128;\n            if (x & 0x200000000000000000000000 > 0) result = (result * 0x100000000162E42FEFB2FED257559BDAA) >> 128;\n            if (x & 0x100000000000000000000000 > 0) result = (result * 0x1000000000B17217F7D5A7716BBA4A9AF) >> 128;\n            if (x & 0x80000000000000000000000 > 0) result = (result * 0x100000000058B90BFBE9DDBAC5E109CCF) >> 128;\n            if (x & 0x40000000000000000000000 > 0) result = (result * 0x10000000002C5C85FDF4B15DE6F17EB0E) >> 128;\n            if (x & 0x20000000000000000000000 > 0) result = (result * 0x1000000000162E42FEFA494F1478FDE05) >> 128;\n            if (x & 0x10000000000000000000000 > 0) result = (result * 0x10000000000B17217F7D20CF927C8E94D) >> 128;\n            if (x & 0x8000000000000000000000 > 0) result = (result * 0x1000000000058B90BFBE8F71CB4E4B33E) >> 128;\n            if (x & 0x4000000000000000000000 > 0) result = (result * 0x100000000002C5C85FDF477B662B26946) >> 128;\n            if (x & 0x2000000000000000000000 > 0) result = (result * 0x10000000000162E42FEFA3AE53369388D) >> 128;\n            if (x & 0x1000000000000000000000 > 0) result = (result * 0x100000000000B17217F7D1D351A389D41) >> 128;\n            if (x & 0x800000000000000000000 > 0) result = (result * 0x10000000000058B90BFBE8E8B2D3D4EDF) >> 128;\n            if (x & 0x400000000000000000000 > 0) result = (result * 0x1000000000002C5C85FDF4741BEA6E77F) >> 128;\n            if (x & 0x200000000000000000000 > 0) result = (result * 0x100000000000162E42FEFA39FE95583C3) >> 128;\n            if (x & 0x100000000000000000000 > 0) result = (result * 0x1000000000000B17217F7D1CFB72B45E3) >> 128;\n            if (x & 0x80000000000000000000 > 0) result = (result * 0x100000000000058B90BFBE8E7CC35C3F2) >> 128;\n            if (x & 0x40000000000000000000 > 0) result = (result * 0x10000000000002C5C85FDF473E242EA39) >> 128;\n            if (x & 0x20000000000000000000 > 0) result = (result * 0x1000000000000162E42FEFA39F02B772C) >> 128;\n            if (x & 0x10000000000000000000 > 0) result = (result * 0x10000000000000B17217F7D1CF7D83C1A) >> 128;\n            if (x & 0x8000000000000000000 > 0) result = (result * 0x1000000000000058B90BFBE8E7BDCBE2E) >> 128;\n            if (x & 0x4000000000000000000 > 0) result = (result * 0x100000000000002C5C85FDF473DEA871F) >> 128;\n            if (x & 0x2000000000000000000 > 0) result = (result * 0x10000000000000162E42FEFA39EF44D92) >> 128;\n            if (x & 0x1000000000000000000 > 0) result = (result * 0x100000000000000B17217F7D1CF79E949) >> 128;\n            if (x & 0x800000000000000000 > 0) result = (result * 0x10000000000000058B90BFBE8E7BCE545) >> 128;\n            if (x & 0x400000000000000000 > 0) result = (result * 0x1000000000000002C5C85FDF473DE6ECA) >> 128;\n            if (x & 0x200000000000000000 > 0) result = (result * 0x100000000000000162E42FEFA39EF366F) >> 128;\n            if (x & 0x100000000000000000 > 0) result = (result * 0x1000000000000000B17217F7D1CF79AFA) >> 128;\n            if (x & 0x80000000000000000 > 0) result = (result * 0x100000000000000058B90BFBE8E7BCD6E) >> 128;\n            if (x & 0x40000000000000000 > 0) result = (result * 0x10000000000000002C5C85FDF473DE6B3) >> 128;\n            if (x & 0x20000000000000000 > 0) result = (result * 0x1000000000000000162E42FEFA39EF359) >> 128;\n            if (x & 0x10000000000000000 > 0) result = (result * 0x10000000000000000B17217F7D1CF79AC) >> 128;\n\n            // Multiply the result by the integer part 2^n + 1. We have to shift by one bit extra because we have already divided\n            // by two when we set the result equal to 0.5 above.\n            result = result << ((x >> 128) + 1);\n\n            // Convert the result to the signed 60.18-decimal fixed-point format.\n            result = PRBMathCommon.mulDiv(result, 1e18, 2**128);\n        }\n    }\n\n    /// @notice Calculates floor(x*y÷denominator) with full precision.\n    ///\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv.\n    ///\n    /// Requirements:\n    /// - The denominator cannot be zero.\n    /// - The result must fit within uint256.\n    ///\n    /// Caveats:\n    /// - This function does not work with fixed-point numbers.\n    ///\n    /// @param x The multiplicand as an uint256.\n    /// @param y The multiplier as an uint256.\n    /// @param denominator The divisor as an uint256.\n    /// @return result The result as an uint256.\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2**256 and mod 2**256 - 1, then use\n        // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n        // variables such that product = prod1 * 2**256 + prod0.\n        uint256 prod0; // Least significant 256 bits of the product\n        uint256 prod1; // Most significant 256 bits of the product\n        assembly {\n            let mm := mulmod(x, y, not(0))\n            prod0 := mul(x, y)\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n        }\n\n        // Handle non-overflow cases, 256 by 256 division\n        if (prod1 == 0) {\n            require(denominator > 0);\n            assembly {\n                result := div(prod0, denominator)\n            }\n            return result;\n        }\n\n        // Make sure the result is less than 2**256. Also prevents denominator == 0.\n        require(denominator > prod1);\n\n        ///////////////////////////////////////////////\n        // 512 by 256 division.\n        ///////////////////////////////////////////////\n\n        // Make division exact by subtracting the remainder from [prod1 prod0].\n        uint256 remainder;\n        assembly {\n            // Compute remainder using mulmod.\n            remainder := mulmod(x, y, denominator)\n\n            // Subtract 256 bit number from 512 bit number\n            prod1 := sub(prod1, gt(remainder, prod0))\n            prod0 := sub(prod0, remainder)\n        }\n\n        // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n        // See https://cs.stackexchange.com/q/138556/92363.\n        unchecked {\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 lpotdod = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by lpotdod.\n                denominator := div(denominator, lpotdod)\n\n                // Divide [prod1 prod0] by lpotdod.\n                prod0 := div(prod0, lpotdod)\n\n                // Flip lpotdod such that it is 2**256 / lpotdod. If lpotdod is zero, then it becomes one.\n                lpotdod := add(div(sub(0, lpotdod), lpotdod), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * lpotdod;\n\n            // Invert denominator mod 2**256. Now that denominator is an odd number, it has an inverse modulo 2**256 such\n            // that denominator * inv = 1 mod 2**256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2**4\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Now use Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2**8\n            inverse *= 2 - denominator * inverse; // inverse mod 2**16\n            inverse *= 2 - denominator * inverse; // inverse mod 2**32\n            inverse *= 2 - denominator * inverse; // inverse mod 2**64\n            inverse *= 2 - denominator * inverse; // inverse mod 2**128\n            inverse *= 2 - denominator * inverse; // inverse mod 2**256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2**256. Since the precoditions guarantee that the outcome is\n            // less than 2**256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n}\n/* solhint-enable */\n"
    },
    "contracts/lib/PRBMathSD59x18.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity 0.8.13;\n\nimport \"./PRBMathCommon.sol\";\n\n/* solhint-disable */\n/// @title PRBMathSD59x18\n/// @author Paul Razvan Berg\n/// @notice Smart contract library for advanced fixed-point math. It works with int256 numbers considered to have 18\n/// trailing decimals. We call this number representation signed 59.18-decimal fixed-point, since the numbers can have\n/// a sign and there can be up to 59 digits in the integer part and up to 18 decimals in the fractional part. The numbers\n/// are bound by the minimum and the maximum values permitted by the Solidity type int256.\nlibrary PRBMathSD59x18 {\n    /// @dev log2(e) as a signed 59.18-decimal fixed-point number.\n    int256 internal constant LOG2_E = 1442695040888963407;\n\n    /// @dev Half the SCALE number.\n    int256 internal constant HALF_SCALE = 5e17;\n\n    /// @dev The maximum value a signed 59.18-decimal fixed-point number can have.\n    int256 internal constant MAX_SD59x18 = 57896044618658097711785492504343953926634992332820282019728792003956564819967;\n\n    /// @dev How many trailing decimals can be represented.\n    int256 internal constant SCALE = 1e18;\n\n    /// INTERNAL FUNCTIONS ///\n\n\n    /// @notice Calculates the natural exponent of x.\n    ///\n    /// @dev Based on the insight that e^x = 2^(x * log2(e)).\n    ///\n    /// Requirements:\n    /// - All from \"log2\".\n    /// - x must be less than 88722839111672999628.\n    ///\n    /// @param x The exponent as a signed 59.18-decimal fixed-point number.\n    /// @return result The result as a signed 59.18-decimal fixed-point number.\n    function exp(int256 x) internal pure returns (int256 result) {\n        // Without this check, the value passed to \"exp2\" would be less than -59794705707972522261.\n        if (x < -41446531673892822322) {\n            return 0;\n        }\n\n        // Without this check, the value passed to \"exp2\" would be greater than 128e18.\n        require(x < 88722839111672999628);\n\n        // Do the fixed-point multiplication inline to save gas.\n        unchecked {\n            int256 doubleScaleProduct = x * LOG2_E;\n            result = exp2((doubleScaleProduct + HALF_SCALE) / SCALE);\n        }\n    }\n\n    /// @notice Calculates the binary exponent of x using the binary fraction method.\n    ///\n    /// @dev See https://ethereum.stackexchange.com/q/79903/24693.\n    ///\n    /// Requirements:\n    /// - x must be 128e18 or less.\n    /// - The result must fit within MAX_SD59x18.\n    ///\n    /// Caveats:\n    /// - For any x less than -59794705707972522261, the result is zero.\n    ///\n    /// @param x The exponent as a signed 59.18-decimal fixed-point number.\n    /// @return result The result as a signed 59.18-decimal fixed-point number.\n    function exp2(int256 x) internal pure returns (int256 result) {\n        // This works because 2^-x = 1/2^x.\n        if (x < 0) {\n            // 2**59.794705707972522262 is the maximum number whose inverse does not equal zero.\n            if (x < -59794705707972522261) {\n                return 0;\n            }\n\n            // Do the fixed-point inversion inline to save gas. The numerator is SCALE * SCALE.\n            unchecked { result = 1e36 / exp2(-x); }\n            return result;\n        } else {\n            // 2**128 doesn't fit within the 128.128-bit fixed-point representation.\n            require(x < 128e18);\n\n            unchecked {\n                // Convert x to the 128.128-bit fixed-point format.\n                uint256 x128x128 = (uint256(x) << 128) / uint256(SCALE);\n\n                // Safe to convert the result to int256 directly because the maximum input allowed is 128e18.\n                result = int256(PRBMathCommon.exp2(x128x128));\n            }\n        }\n    }\n}\n/* solhint-enable */\n"
    },
    "contracts/utils/TwoStepOwnable.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.7.6 <0.9.0;\n\n/// @title TwoStepOwnable\n/// @notice Contract that implements the same functionality as popular Ownable contract from openzeppelin library.\n/// The only difference is that it adds a possibility to transfer ownership in two steps. Single step ownership\n/// transfer is still supported.\n/// @dev Two step ownership transfer is meant to be used by humans to avoid human error. Single step ownership\n/// transfer is meant to be used by smart contracts to avoid over-complicated two step integration. For that reason,\n/// both ways are supported.\nabstract contract TwoStepOwnable {\n    /// @dev current owner\n    address private _owner;\n    /// @dev candidate to an owner\n    address private _pendingOwner;\n\n    /// @notice Emitted when ownership is transferred on `transferOwnership` and `acceptOwnership`\n    /// @param newOwner new owner\n    event OwnershipTransferred(address indexed newOwner);\n    /// @notice Emitted when ownership transfer is proposed, aka pending owner is set\n    /// @param newPendingOwner new proposed/pending owner\n    event OwnershipPending(address indexed newPendingOwner);\n\n    /**\n     *  error OnlyOwner();\n     *  error OnlyPendingOwner();\n     *  error OwnerIsZero();\n     */\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        if (owner() != msg.sender) revert(\"OnlyOwner\");\n        _;\n    }\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _setOwner(msg.sender);\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) revert(\"OwnerIsZero\");\n        _setOwner(newOwner);\n    }\n\n    /**\n     * @dev Transfers pending ownership of the contract to a new account (`newPendingOwner`) and clears any existing\n     * pending ownership.\n     * Can only be called by the current owner.\n     */\n    function transferPendingOwnership(address newPendingOwner) public virtual onlyOwner {\n        _setPendingOwner(newPendingOwner);\n    }\n\n    /**\n     * @dev Clears the pending ownership.\n     * Can only be called by the current owner.\n     */\n    function removePendingOwnership() public virtual onlyOwner {\n        _setPendingOwner(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a pending owner\n     * Can only be called by the pending owner.\n     */\n    function acceptOwnership() public virtual {\n        if (msg.sender != pendingOwner()) revert(\"OnlyPendingOwner\");\n        _setOwner(pendingOwner());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Returns the address of the pending owner.\n     */\n    function pendingOwner() public view virtual returns (address) {\n        return _pendingOwner;\n    }\n\n    /**\n     * @dev Sets the new owner and emits the corresponding event.\n     */\n    function _setOwner(address newOwner) private {\n        if (_owner == newOwner) revert(\"OwnerDidNotChange\");\n\n        _owner = newOwner;\n        emit OwnershipTransferred(newOwner);\n\n        if (_pendingOwner != address(0)) {\n            _setPendingOwner(address(0));\n        }\n    }\n\n    /**\n     * @dev Sets the new pending owner and emits the corresponding event.\n     */\n    function _setPendingOwner(address newPendingOwner) private {\n        if (_pendingOwner == newPendingOwner) revert(\"PendingOwnerDidNotChange\");\n\n        _pendingOwner = newPendingOwner;\n        emit OwnershipPending(newPendingOwner);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates",
          "devdoc",
          "userdoc"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}